<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Particle Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .control-row {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            min-width: 100px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h3>Water Simulator</h3>
        <div class="control-row">
            <label>Particles:</label>
            <input type="range" id="particleCount" min="100" max="800" value="400" step="50">
            <span id="particleCountValue">400</span>
        </div>
        <div class="control-row">
            <label>Gravity:</label>
            <input type="range" id="gravity" min="0.1" max="1.0" value="0.5" step="0.1">
            <span id="gravityValue">0.5</span>
        </div>
        <div class="control-row">
            <button id="resetButton">Reset Water</button>
        </div>
    </div>
    
    <div id="info">
        Drag to rotate sphere â€¢ Scroll to zoom<br>
        Watch water pool at the bottom and slosh around
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class WaterSimulator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = [];
                this.particleSystem = null;
                this.sphere = null;
                this.sphereRadius = 3;
                
                // Simple physics parameters
                this.gravity = 0.5;
                this.particleCount = 400;
                this.timeStep = 0.016;
                
                // Mouse controls
                this.isMouseDown = false;
                this.mouseDownPos = new THREE.Vector2();
                this.sphereRotation = new THREE.Euler();
                this.targetRotation = new THREE.Euler();
                
                this.init();
                this.setupControls();
                this.animate();
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001122);
                
                // Camera setup
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 8);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Create transparent sphere container
                const sphereGeometry = new THREE.SphereGeometry(this.sphereRadius, 64, 64);
                const sphereMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x666666, 
                    wireframe: true,
                    transparent: true,
                    opacity: 0.2
                });
                this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                this.scene.add(this.sphere);
                
                // Create water particles
                this.createWaterParticles();
                
                // Event listeners
                window.addEventListener('resize', () => this.onWindowResize());
                this.renderer.domElement.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.renderer.domElement.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.renderer.domElement.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.renderer.domElement.addEventListener('wheel', (e) => this.onWheel(e));
            }
            
            createWaterParticles() {
                // Remove existing particles
                if (this.particleSystem) {
                    this.scene.remove(this.particleSystem);
                }
                
                this.particles = [];
                const positions = new Float32Array(this.particleCount * 3);
                
                // Create particles filling about 1/3 of the sphere volume
                for (let i = 0; i < this.particleCount; i++) {
                    // Larger water volume - fill more of the bottom hemisphere
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * (this.sphereRadius * 0.8); // Increased from 0.4
                    const height = -this.sphereRadius + 0.3 + Math.random() * 2.2; // Increased range significantly
                    
                    const x = radius * Math.cos(angle);
                    const y = height;
                    const z = radius * Math.sin(angle);
                    
                    const particle = {
                        position: new THREE.Vector3(x, y, z),
                        oldPosition: new THREE.Vector3(x, y, z),
                        velocity: new THREE.Vector3(0, 0, 0)
                    };
                    
                    this.particles.push(particle);
                    
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y;
                    positions[i * 3 + 2] = z;
                }
                
                // Create visual representation
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.15,
                    color: 0x4499ff,
                    transparent: true,
                    opacity: 0.8,
                    sizeAttenuation: true
                });
                
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            }
            
            updatePhysics() {
                const dt = this.timeStep;
                const sphereRadiusSquared = this.sphereRadius * this.sphereRadius;
                
                // Calculate gravity direction relative to sphere rotation
                // This makes particles always fall toward the "bottom" of the rotated sphere
                const worldGravity = new THREE.Vector3(0, -this.gravity, 0);
                const sphereMatrix = new THREE.Matrix4().makeRotationFromEuler(this.sphereRotation);
                const inverseMatrix = sphereMatrix.clone().invert();
                const localGravity = worldGravity.clone().applyMatrix4(inverseMatrix);
                
                // Update each particle
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Store old position for collision response
                    particle.oldPosition.copy(particle.position);
                    
                    // Apply gravity in sphere's local coordinate system
                    particle.velocity.add(localGravity.clone().multiplyScalar(dt));
                    
                    // Particle-particle collision detection and fluid cohesion
                    let cohesionForce = new THREE.Vector3(0, 0, 0);
                    let neighborCount = 0;
                    
                    for (let j = 0; j < this.particles.length; j++) {
                        if (i === j) continue;
                        
                        const other = this.particles[j];
                        const diff = new THREE.Vector3().subVectors(other.position, particle.position);
                        const distanceSquared = diff.lengthSq();
                        const maxDistance = 0.25;
                        const maxDistanceSquared = maxDistance * maxDistance;
                        
                        if (distanceSquared < maxDistanceSquared && distanceSquared > 0.001) {
                            const distance = Math.sqrt(distanceSquared);
                            const direction = diff.clone().normalize();
                            
                            // Gentler particle-particle collision (prevent overlap)
                            const minDistance = 0.08;
                            if (distance < minDistance) {
                                const overlap = minDistance - distance;
                                const pushForce = direction.clone().multiplyScalar(-0.2 * overlap / dt);
                                particle.velocity.add(pushForce);
                                
                                // Also push particles apart positionally for stability
                                particle.position.add(direction.clone().multiplyScalar(-overlap * 0.3));
                            }
                            
                            // Gentle attraction to keep particles together like water
                            else if (distance < maxDistance) {
                                const attraction = direction.multiplyScalar(0.03 * (maxDistance - distance));
                                cohesionForce.add(attraction);
                                neighborCount++;
                            }
                        }
                    }
                    
                    if (neighborCount > 0) {
                        cohesionForce.divideScalar(neighborCount);
                        particle.velocity.add(cohesionForce);
                    }
                    
                    // Update position
                    particle.position.add(particle.velocity.clone().multiplyScalar(dt));
                    
                    // Sphere collision - keep particles inside with less bounce
                    const distanceFromCenter = particle.position.lengthSq();
                    if (distanceFromCenter >= sphereRadiusSquared - 0.01) {
                        // Move particle back inside sphere
                        const normal = particle.position.clone().normalize();
                        particle.position.copy(normal.multiplyScalar(this.sphereRadius - 0.02));
                        
                        // Much gentler wall collision - less bouncy
                        const velocityDotNormal = particle.velocity.dot(normal);
                        if (velocityDotNormal > 0) {
                            particle.velocity.sub(normal.multiplyScalar(velocityDotNormal * 0.3));
                        }
                        
                        // More energy loss on wall collision
                        particle.velocity.multiplyScalar(0.6);
                    }
                    
                    // Apply general damping to prevent unrealistic motion
                    particle.velocity.multiplyScalar(0.99);
                }
                
                // Update visual positions
                const positions = this.particleSystem.geometry.attributes.position.array;
                for (let i = 0; i < this.particles.length; i++) {
                    positions[i * 3] = this.particles[i].position.x;
                    positions[i * 3 + 1] = this.particles[i].position.y;
                    positions[i * 3 + 2] = this.particles[i].position.z;
                }
                this.particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            setupControls() {
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    this.particleCount = parseInt(e.target.value);
                    document.getElementById('particleCountValue').textContent = this.particleCount;
                    this.createWaterParticles();
                });
                
                document.getElementById('gravity').addEventListener('input', (e) => {
                    this.gravity = parseFloat(e.target.value);
                    document.getElementById('gravityValue').textContent = this.gravity;
                });
                
                document.getElementById('resetButton').addEventListener('click', () => {
                    this.createWaterParticles();
                });
            }
            
            onMouseDown(event) {
                this.isMouseDown = true;
                this.mouseDownPos.set(event.clientX, event.clientY);
            }
            
            onMouseMove(event) {
                if (this.isMouseDown) {
                    const deltaX = event.clientX - this.mouseDownPos.x;
                    const deltaY = event.clientY - this.mouseDownPos.y;
                    
                    this.targetRotation.y += deltaX * 0.01;
                    this.targetRotation.x += deltaY * 0.01;
                    
                    this.mouseDownPos.set(event.clientX, event.clientY);
                }
            }
            
            onMouseUp(event) {
                this.isMouseDown = false;
            }
            
            onWheel(event) {
                event.preventDefault();
                const zoom = event.deltaY * 0.01;
                this.camera.position.z = Math.max(4, Math.min(15, this.camera.position.z + zoom));
            }
            
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Smooth rotation
                this.sphereRotation.x += (this.targetRotation.x - this.sphereRotation.x) * 0.05;
                this.sphereRotation.y += (this.targetRotation.y - this.sphereRotation.y) * 0.05;
                
                // Rotate both sphere and particles together
                this.sphere.rotation.copy(this.sphereRotation);
                this.particleSystem.rotation.copy(this.sphereRotation);
                
                this.updatePhysics();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start the simulation
        new WaterSimulator();
    </script>
</body>
</html>